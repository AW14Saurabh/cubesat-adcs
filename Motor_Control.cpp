/*******************************************************************************
 * This library is an interface to the 3 reaction wheel motors. Calculates error
 * and adjust motor for detumbling and point functions.
 ******************************************************************************/
#include "Motor_Control.h"

/*******************************************************************************
 PRIVATE FUNCTIONS
 ******************************************************************************/

/******************************************************************************/
/*!
    @brief  Calculate combined angular momentum to be generated by all wheels
*/
/******************************************************************************/
void Motor_Control::detumble()
{
    double P = -0.1;
    // Serial.print(_satAngVel->x);
    // Serial.print(_satAngVel->y);
    // Serial.println(_satAngVel->z);
    Serial.println("SatAngVel:\t\t" + String(_satAngVel->x) + "\t" + String(_satAngVel->y) + "\t" + String(_satAngVel->z));
    Serial.println("Delta: " + String(_dt));
    double error[3] {0.0, 0.0, 0.0};
    error[0] = 0.0 - _satAngVel->x;
    error[1] = 0.0 - _satAngVel->y;
    error[2] = 0.0 - _satAngVel->z;
    // Serial.print(error[0]);
    // Serial.print(error[1]);
    // Serial.println(error[2]);
    Serial.println("Error:\t" + String(error[0]) + "\t" + String(error[1]) + "\t" + String(error[2]));
    _satAngMom.x = P * error[0] * _dt;
    _satAngMom.y = P * error[1] * _dt;
    _satAngMom.z = P * error[2] * _dt;
    // Serial.print(_satAngMom.x);
    // Serial.print(_satAngMom.y);
    // Serial.println(_satAngMom.z);
    Serial.println("Momentum:\t" + String(_satAngMom.x) + "\t" + String(_satAngMom.y) + "\t" + String(_satAngMom.z));
}

/******************************************************************************/
/*!
    @brief  Calculate combined angular momentum required from all wheels,
            only affects yaw angle. Target Angles are in degrees.
*/
/******************************************************************************/
void Motor_Control::point(angRPYData_t *targetAng)
{
    angRPYData_t error;

    error.x = targetAng->x * PI / 180 - _satAngles->x;
    error.y = targetAng->y * PI / 180 - _satAngles->y;
    error.z = targetAng->z * PI / 180 - _satAngles->z;

    while (error.z  >  PI) error.z -= 2 * PI;
    while (error.z <= -PI) error.z += 2 * PI;

    float P = -0.001;
    float D =  0.003;
    _satAngMom.x = (P * error.x + D * _satAngVel->x) * _dt;
    _satAngMom.y = (P * error.y + D * _satAngVel->y) * _dt;
    _satAngMom.z = (P * error.z + D * _satAngVel->z) * _dt;
}

/******************************************************************************/
/*!
    @brief  Distribute combined angular momentum to each wheel, calculate
            scaled angular velocity for each wheel.
*/
/******************************************************************************/
void Motor_Control::calcWheelAngVel()
{
    /*
    Convert satellite angular momentum to wheel angular velocity change and add 
    to current wheel angular velocity. Since motors are on the axes there is no
    complex momentum distribution math involved.
    */
    float wheelAngVelDelta[3];
    wheelAngVelDelta[0] = _satAngMom.x / WHEEL_I;
    wheelAngVelDelta[1] = _satAngMom.y / WHEEL_I;
    wheelAngVelDelta[2] = _satAngMom.z / WHEEL_I;

    /* Scale down angVelDelta if accel is too large */
    float maxAngVelDelta = 0;
    for (int i = 0; i < 3; i++)
        maxAngVelDelta = max(abs(wheelAngVelDelta[i]), maxAngVelDelta);
    float maxVelDeltaAllowed = MOTOR_MAX_ACCEL * _dt;
    if (maxAngVelDelta > maxVelDeltaAllowed)
    {
        wheelAngVelDelta[0] *= maxVelDeltaAllowed / maxAngVelDelta;
        wheelAngVelDelta[1] *= maxVelDeltaAllowed / maxAngVelDelta;
        wheelAngVelDelta[2] *= maxVelDeltaAllowed / maxAngVelDelta;
    }

    /* If motors are saturated, don't update */
    float maxAngVel = 0;
    for (int i = 0; i < 3; i++)
        maxAngVel = max(abs(_wheelAngVel[i] + wheelAngVelDelta[i]), maxAngVel);
    if (maxAngVel > MAX_MOTOR_W)
    {
        wheelAngVelDelta[0] = 0;
        wheelAngVelDelta[1] = 0;
        wheelAngVelDelta[2] = 0;
    }

    _wheelAngVel[0] += wheelAngVelDelta[0];
    _wheelAngVel[1] += wheelAngVelDelta[1];
    _wheelAngVel[2] += wheelAngVelDelta[2];
}

/******************************************************************************/
/*!
    @brief  Convert wheel angular velocity to PWM signal and send to the motors.
*/
/******************************************************************************/
void Motor_Control::setMotor()
{
    bool dir[3];
    float spd[3];
    for (int i = 0; i < 3; i++)
    {
        dir[i] = _wheelAngVel[i] < 0; //Change < to >= to reverse the working.
        spd[i] = map(abs(_wheelAngVel[i]), 0, MAX_MOTOR_W, 0, MAX_MOTOR_PWM);
    }

    digitalWrite(MOT_R_IN1,  dir[0]);
    digitalWrite(MOT_R_IN2, !dir[0]);
    digitalWrite(MOT_P_IN1,  dir[1]);
    digitalWrite(MOT_P_IN2, !dir[1]);
    digitalWrite(MOT_Y_IN1,  dir[2]);
    digitalWrite(MOT_Y_IN2, !dir[2]);
    analogWrite(MOT_R_SPD,  spd[0]);
    analogWrite(MOT_P_SPD,  spd[1]);
    analogWrite(MOT_Y_SPD,  spd[2]);
}

/*******************************************************************************
 CONSTRUCTOR
 ******************************************************************************/

/******************************************************************************/
/*!
    @brief  Instantiates a new Motor_Control class
*/
/******************************************************************************/
Motor_Control::Motor_Control(angVelData_t *angVel, angRPYData_t *ang) : _satAngVel(angVel),
                                                                        _satAngles(ang),
                                                                        _satAngMom{0,0,0},
                                                                        _wheelAngVel{0,0,0},
                                                                        _dt (0)
{
    pinMode(MOT_Y_IN1, OUTPUT);
    pinMode(MOT_Y_IN2, OUTPUT);
    pinMode(MOT_Y_SPD, OUTPUT);
    pinMode(MOT_R_IN1, OUTPUT);
    pinMode(MOT_R_IN2, OUTPUT);
    pinMode(MOT_R_SPD, OUTPUT);
    pinMode(MOT_P_IN1, OUTPUT);
    pinMode(MOT_P_IN2, OUTPUT);
    pinMode(MOT_P_SPD, OUTPUT);

    digitalWrite(MOT_Y_IN1,LOW);
    digitalWrite(MOT_R_IN1,LOW);
    digitalWrite(MOT_P_IN1,LOW);
    digitalWrite(MOT_Y_IN2,HIGH);
    digitalWrite(MOT_R_IN2,HIGH);
    digitalWrite(MOT_P_IN2,HIGH);
    analogWrite(MOT_Y_SPD, MAX_MOTOR_PWM);
    analogWrite(MOT_R_SPD, MAX_MOTOR_PWM);
    analogWrite(MOT_P_SPD, MAX_MOTOR_PWM);
    // Serial.println("Waiting 10 seconds to check motor output");
    // delay(10000);
}

/*******************************************************************************
 PUBLIC FUNCTIONS
 ******************************************************************************/

/******************************************************************************/
/*!
    @brief  Update motors from gathered data
*/
/******************************************************************************/
void Motor_Control::updateMotor(messageData_t *message, int dtMillis)
{
    _dt = (float) dtMillis / 1000.0;
    // Serial.println("Delta: " + String(_dt));
    if (message->opMode)
        detumble();
    else
        point(&message->targetAngles);
    calcWheelAngVel();
    setMotor();
}
