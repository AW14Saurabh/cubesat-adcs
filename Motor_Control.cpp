/*******************************************************************************
 * This library is an interface to the 3 reaction wheel motors. Calculates error
 * and adjust motor for detumbling and point functions.
 ******************************************************************************/
#include "Motor_Control.h"

/*******************************************************************************
 PRIVATE FUNCTIONS
 ******************************************************************************/

/******************************************************************************/
/*!
    @brief  Calculate combined angular momentum to be generated by all wheels
*/
/******************************************************************************/
void Motor_Control::detumble()
{
    float P = 2.0;
    // Serial.println("SatAngVel:\t\t" + String(_satAngVel->x) + "\t" + String(_satAngVel->y) + "\t" + String(_satAngVel->z));
    _satAngMom.x = P * (0.0 - _satAngVel->x);
    _satAngMom.y = P * (0.0 - _satAngVel->y);
    _satAngMom.z = P * (0.0 - _satAngVel->z);
    // Serial.println("Momentum:\t" + String(_satAngMom.x) + "\t" + String(_satAngMom.y) + "\t" + String(_satAngMom.z));
}

/******************************************************************************/
/*!
    @brief  Calculate combined angular momentum required from all wheels,
            only affects yaw angle. Target Angles are in degrees.
*/
/******************************************************************************/
void Motor_Control::point(angRPYData_t *targetAng)
{
    angRPYData_t error;

    error.x = _satAngles->x - targetAng->x;
    error.y = _satAngles->y - targetAng->y;
    error.z = _satAngles->z - targetAng->z;

    float P = 2.25;
    float D = 2.0;
    _satAngMom.x = D * (P * error.x + _satAngVel->x);
    _satAngMom.y = D * (P * error.y + _satAngVel->y);
    _satAngMom.z = D * (P * error.z + _satAngVel->z);
}

/******************************************************************************/
/*!
    @brief  Distribute combined angular momentum to each wheel, calculate
            scaled angular velocity for each wheel.
*/
/******************************************************************************/
void Motor_Control::calcWheelAngVel()
{
    /*
    Convert satellite angular momentum to wheel angular velocity change and add 
    to current wheel angular velocity. Since motors are on the axes there is no
    complex momentum distribution math involved.
    */
    float wheelAngVelDelta[3];
    wheelAngVelDelta[0] = _satAngMom.x / WHEEL_I;
    wheelAngVelDelta[1] = _satAngMom.y / WHEEL_I;
    wheelAngVelDelta[2] = _satAngMom.z / WHEEL_I;
    // Serial.println("WhlWD: " + String(wheelAngVelDelta[0], 4) + " " + String(wheelAngVelDelta[1], 4) + " " + String(wheelAngVelDelta[2], 4));
    /* Scale down angVelDelta if accel is too large */
    // float maxAngVelDelta = 0;
    // for (int i = 0; i < 3; i++)
    //     maxAngVelDelta = max(abs(wheelAngVelDelta[i]), maxAngVelDelta);
    // float maxVelDeltaAllowed = MOTOR_MAX_ACCEL * _dt;
    // Serial.println("Delta Time: " + String(_dt));
    // if (maxAngVelDelta > maxVelDeltaAllowed)
    // {
    //     wheelAngVelDelta[0] *= maxVelDeltaAllowed / maxAngVelDelta;
    //     wheelAngVelDelta[1] *= maxVelDeltaAllowed / maxAngVelDelta;
    //     wheelAngVelDelta[2] *= maxVelDeltaAllowed / maxAngVelDelta;
    // }

    /* If motors are saturated, don't update */
    wheelAngVelDelta[0] = abs(_wheelAngVel[0] + wheelAngVelDelta[0]) < MAX_MOTOR_W ? wheelAngVelDelta[0] : 0;
    wheelAngVelDelta[1] = abs(_wheelAngVel[1] + wheelAngVelDelta[1]) < MAX_MOTOR_W ? wheelAngVelDelta[1] : 0;
    wheelAngVelDelta[2] = abs(_wheelAngVel[2] + wheelAngVelDelta[2]) < MAX_MOTOR_W ? wheelAngVelDelta[2] : 0;

    _wheelAngVel[0] += wheelAngVelDelta[0];
    _wheelAngVel[1] += wheelAngVelDelta[1];
    _wheelAngVel[2] += wheelAngVelDelta[2];
    // Serial.println("WheelWDelta: " + String(wheelAngVelDelta[0]) + " " + String(wheelAngVelDelta[1]) + " " + String(wheelAngVelDelta[2]));
    // Serial.println("wheelW:      " + String(_wheelAngVel[0]) + " " + String(_wheelAngVel[1]) + " " + String(_wheelAngVel[2]));
}

/******************************************************************************/
/*!
    @brief  Convert wheel angular velocity to PWM signal and send to the motors.
*/
/******************************************************************************/
void Motor_Control::setMotor()
{
    digitalWrite(MOT_R_IN1, _satAngMom.x < 0 ? LOW : HIGH);
    digitalWrite(MOT_R_IN2, _satAngMom.x < 0 ? HIGH : LOW);
    digitalWrite(MOT_P_IN1, _satAngMom.y < 0 ? HIGH : LOW);
    digitalWrite(MOT_P_IN2, _satAngMom.y < 0 ? LOW : HIGH);
    digitalWrite(MOT_Y_IN1, _satAngMom.z < 0 ? LOW : HIGH);
    digitalWrite(MOT_Y_IN2, _satAngMom.z < 0 ? HIGH : LOW);
     analogWrite(MOT_R_SPD, 255 * min(1.0, abs(_satAngMom.x)));
     analogWrite(MOT_P_SPD, 255 * min(1.0, abs(_satAngMom.y)));
     analogWrite(MOT_Y_SPD, 255 * min(1.0, abs(_satAngMom.z)));
}

/*******************************************************************************
 CONSTRUCTOR
 ******************************************************************************/

/******************************************************************************/
/*!
    @brief  Instantiates a new Motor_Control class
*/
/******************************************************************************/
Motor_Control::Motor_Control(angVelData_t *angVel, angRPYData_t *ang) : _satAngVel(angVel),
                                                                        _satAngles(ang),
                                                                        _satAngMom{0,0,0},
                                                                        _wheelAngVel{0,0,0}
{
    pinMode(MOT_Y_IN1, OUTPUT);
    pinMode(MOT_Y_IN2, OUTPUT);
    pinMode(MOT_Y_SPD, OUTPUT);
    pinMode(MOT_R_IN1, OUTPUT);
    pinMode(MOT_R_IN2, OUTPUT);
    pinMode(MOT_R_SPD, OUTPUT);
    pinMode(MOT_P_IN1, OUTPUT);
    pinMode(MOT_P_IN2, OUTPUT);
    pinMode(MOT_P_SPD, OUTPUT);

    digitalWrite(MOT_Y_IN1,LOW);
    digitalWrite(MOT_R_IN1,LOW);
    digitalWrite(MOT_P_IN1,LOW);
    digitalWrite(MOT_Y_IN2,HIGH);
    digitalWrite(MOT_R_IN2,HIGH);
    digitalWrite(MOT_P_IN2,HIGH);
    analogWrite(MOT_Y_SPD, 180);
    analogWrite(MOT_R_SPD, 180);
    analogWrite(MOT_P_SPD, 180);
}

/*******************************************************************************
 PUBLIC FUNCTIONS
 ******************************************************************************/

/******************************************************************************/
/*!
    @brief  Update motors from gathered data
*/
/******************************************************************************/
void Motor_Control::updateMotor(messageData_t *message)
{
    if (message->opMode)
        detumble();
    else
        point(&message->targetAngles);
    // calcWheelAngVel();
    setMotor();
}
