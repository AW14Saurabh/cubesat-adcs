/*******************************************************************************
 * This library is an interface to the 3 reaction wheel motors. Calculates error
 * and adjust motor for detumbling and point functions.
 ******************************************************************************/
#include "Motor_Control.h"

/*******************************************************************************
 PRIVATE FUNCTIONS
 ******************************************************************************/

/******************************************************************************/
/*!
    @brief  Compute angle in radians from the quaternions
*/
/******************************************************************************/
void Motor_Control::computeAngles(angRPYData_t *satAngles)
{
    satAngles->x = atan2f(_satAttitude.a * _satAttitude.b +
                              _satAttitude.c * _satAttitude.d,
                          0.5f -
                              _satAttitude.b * _satAttitude.b -
                              _satAttitude.c * _satAttitude.c);

    satAngles->y = asinf(-2.0f *
                         (_satAttitude.b * _satAttitude.d -
                          _satAttitude.a * _satAttitude.c));

    satAngles->z = atan2f(_satAttitude.b * _satAttitude.c +
                              _satAttitude.a * _satAttitude.d,
                          0.5f -
                              _satAttitude.c * _satAttitude.c -
                              _satAttitude.d * _satAttitude.d);
}

/******************************************************************************/
/*!
    @brief  Calculate combined angular momentum to be generated by all wheels
*/
/******************************************************************************/
void Motor_Control::detumble()
{
    float P = -0.003;
    _satAngMom.x = P * (0 - _satAngVel.x) * _dt;
    _satAngMom.y = P * (0 - _satAngVel.y) * _dt;
    _satAngMom.z = P * (0 - _satAngVel.z) * _dt;
}

/******************************************************************************/
/*!
    @brief  Calculate combined angular momentum required from all wheels,
            only affects yaw angle.
*/
/******************************************************************************/
void Motor_Control::point(float targetAngle)
{
    angRPYData_t satAngles;
    computeAngles(&satAngles);
    float error = targetAngle - satAngles.z;
    while (error  >  PI) error -= 2 * PI;
    while (error <= -PI) error += 2 * PI;
    float P = -0.001;
    float D =  0.003;
    _satAngMom.x = 0;
    _satAngMom.x = 0;
    _satAngMom.x = (P * error + D * _satAngVel.z) * _dt;
}

/******************************************************************************/
/*!
    @brief  Distribute combined angular momentum to each wheel, calculate
            scaled angular velocity for each wheel.
*/
/******************************************************************************/
void Motor_Control::calcWheelAngVel()
{
    float wheelAngVelDelta[3];
    wheelAngVelDelta[0] = _satAngMom.x / WHEEL_I;
    wheelAngVelDelta[1] = _satAngMom.y / WHEEL_I;
    wheelAngVelDelta[2] = _satAngMom.z / WHEEL_I;

    /* Scale down angVelDelta if accel is too large */
    float maxAngVelDelta = 0;
    for (int i = 0; i < 3; i++)
        maxAngVelDelta = max(abs(wheelAngVelDelta[i]), maxAngVelDelta);
    float maxAccel = MOTOR_MAX_ACCEL * _dt;
    if (maxAngVelDelta > maxAccel)
        for (int i = 0; i < 3; i++)
            wheelAngVelDelta[i] *= maxAccel / maxAngVelDelta;

    /* If motors are saturated, don't update */
    float maxAngVel = 0;
    for (int i = 0; i < 3; i++)
        maxAngVel = max(abs(_wheelAngVel[i] + wheelAngVelDelta[i]), maxAngVel);
    if (maxAngVel > MAX_MOTOR_W)
        for (int i = 0; i < 3; i++)
            wheelAngVelDelta[i] = 0;

    for (int i = 0; i < 3; i++)
        _wheelAngVel[i] += wheelAngVelDelta[i];
}

/******************************************************************************/
/*!
    @brief  Distribute combined angular momentum to each wheel, calculate
            scaled angular velocity for each wheel.
*/
/******************************************************************************/
void Motor_Control::setMotor()
{
    int out[3];
    for (int i = 0; i < 3; i++)
        out[i] = constrain(203 - (int) _wheelAngVel[i] * 203 / MAX_MOTOR_W, 0, 203);

    analogWrite(MOT1_SPD, out[0]);
    analogWrite(MOT2_SPD, out[1]);
    analogWrite(MOT3_SPD, out[2]);
}

/*******************************************************************************
 CONSTRUCTOR
 ******************************************************************************/

/******************************************************************************/
/*!
    @brief  Instantiates a new Motor_Control class
*/
/******************************************************************************/
Motor_Control::Motor_Control() : _satAngVel{0,0,0},
                                 _satAttitude{0,0,0,0},
                                 _satAngMom{0,0,0},
                                 _motorFreq{0,0,0},
                                 _wheelAngVel{0,0,0},
                                 _dt (0)
{
    pinMode(MOT1_SPD, OUTPUT);
    pinMode(MOT1_DIR, OUTPUT);
    pinMode(MOT1_FREQ, INPUT);
    pinMode(MOT2_SPD, OUTPUT);
    pinMode(MOT2_DIR, OUTPUT);
    pinMode(MOT2_FREQ, INPUT);
    pinMode(MOT3_SPD, OUTPUT);
    pinMode(MOT3_DIR, OUTPUT);
    pinMode(MOT3_FREQ, INPUT);

    digitalWrite(MOT1_DIR,LOW);
    digitalWrite(MOT2_DIR,LOW);
    digitalWrite(MOT3_DIR,LOW);
    digitalWrite(MOT1_SPD,HIGH);
    digitalWrite(MOT2_SPD,HIGH);
    digitalWrite(MOT3_SPD,HIGH);
}

/*******************************************************************************
 PUBLIC FUNCTIONS
 ******************************************************************************/

/******************************************************************************/
/*!
    @brief  Update motors from gathered data
*/
/******************************************************************************/
void Motor_Control::updateMotor(dataPacket_t heading, messageData_t message, int dtMillis)
{
    _satAngVel = heading.angVel;
    _satAttitude = heading.attitude;
    _dt = (float) dtMillis / 1000.0;

    if (message.mode == DETUMBLE)
        detumble();
    else if (message.mode == POINT)
        point(message.targetAngle);
    calcWheelAngVel();
    if (message.enableState == ENABLED)
        setMotor();
    else
    {
        for (int i = 0; i < 3; i++)
            _wheelAngVel[i] = MOTOR_MIDDLE_SPEED;
        setMotor();
    }
}

/******************************************************************************/
/*!
    @brief  Return Motor operation data
*/
/******************************************************************************/
motFreqData_t Motor_Control::getFrequency()
{
    _motorFreq.x = analogRead(MOT1_FREQ);
    _motorFreq.y = analogRead(MOT2_FREQ);
    _motorFreq.z = analogRead(MOT3_FREQ);

    return _motorFreq;
}